- [모듈](#모듈)
	- [문자열](#문자열)
	- [%서식](#서식)
	- [format() 함수](#format-함수)
	- [f-string](#f-string)
- [튜플](#튜플)
		- [튜플에 항목을 추가하는 방법](#튜플에-항목을-추가하는-방법)
- [세트](#세트)
		- [세트를 지원하는 함수](#세트를-지원하는-함수)
- [자료구조](#자료구조)
- [딕셔너리](#딕셔너리)
		- [get() 함수](#get-함수)
- [스타일 코드](#스타일-코드)
		- [구분자.join(리스트형) 함수](#구분자join리스트형-함수)
		- [split() 함수](#split-함수)
	- [리스트 컴프리헨션](#리스트-컴프리헨션)
		- [enumerate() 함수](#enumerate-함수)
	- [람다함수(lambda)](#람다함수lambda)
	- [맵리듀스의 종류](#맵리듀스의-종류)
	- [reduce() 함수](#reduce-함수)
	- [별표의 사용](#별표의-사용)
	- [절차 지향](#절차-지향)
	- [객체 지향](#객체-지향)
		- [인스턴스](#인스턴스)
- [클래스](#클래스)
	- [클래스 구현하기](#클래스-구현하기)
	- [상속](#상속)
- [상속](#상속-1)
	- [오버라이딩](#오버라이딩)
	- [다형성](#다형성)
	- [크롤러](#크롤러)
	- [가시성](#가시성)
	- [캡슐화](#캡슐화)
	- [정보 은닉](#정보-은닉)
		- [캡슐화를 하는 이유](#캡슐화를-하는-이유)
- [모듈과 패키지](#모듈과-패키지)
		- [인터페이스](#인터페이스)
		- [패키지](#패키지)
		- [네임스페이스](#네임스페이스)
		- [랜덤함수](#랜덤함수)
		- [웹 주소 정보 불러오는 함수](#웹-주소-정보-불러오는-함수)
		- [절대 참조](#절대-참조)
		- [상대 참조](#상대-참조)
	- [try-except](#try-except)
	- [__str__](#str)

# 모듈

재사용이 가능하도록 독립된 파일로 분리해 구성한 파일

프로그램과 같은 폴더에 있어야 함.

하나의 모듈에 하나 이상의 함수를 가질 수 있음

각 함수는 서로 다른 이름을 가져야 함.

## 문자열

**************시퀀스 자료형 ( 순서를 가지고 나열된 객체)**************

데이터를 **순차적으로** 저장

sys.getsizeof : 메모리의 크기 출력

인코딩 : **이진수로** 변환되는 표준 규칙

인덱싱 : 리스트처럼 글자 하나하나가 **상대적인 주소(offset)**를 가지는데 이를 가져옴

슬라이싱 : 문자열의 **부분 값**을 추출 (부분값이란? [0:6] ⇒ 0~6의 자리)

## %서식

| %s | 문자열 |
| --- | --- |
| %c | 문자 1개 |
| %d | 정수 |
| %f | 실수 |
| %o | 8진수 |
| %x | 16진수 |
| %% | 문자 %자체 |

## format() 함수

“{자료형}”.format(인수)

print(”I’m {0} year old.”.format(20))

## f-string

name = “minsu”

score = 90

print(f”(name}의 점수는 {score} 점입니다.”)

# 튜플

리스트에 비해 **빠르게** 동작

튜플 이름 = (값1, 값2, 값3 ‘’’ ) = 값1, 값2, 값3 ‘’’

간단한 생성을 위해 값을 감싸는 괄호는 생략 가능

- 튜플에는 새로운 값을 입력할 수 없음
- 튜플 내부의 리스트 원소는 수정이 가능

### 튜플에 항목을 추가하는 방법

list화 시킨 후 → append()로 추가 → 다시 튜플화 tuple()

# 세트

값을 순서 없이 랜덤으로 **저장**하고, **중복X**

사전과 같이 {} 기호를 사용

사전과 달리 키만 있고 **값이 없다**

### 세트를 지원하는 함수

| add() | 원소 하나를 추가 |
| --- | --- |
| remove(), discard() | 원소 하나를 제거 |
| update() | 새로운 리스트를 그대로 추가 |
| clear() | 모든 변수를 지운다 |

튜플과 다르게 **삭제**, **변경** 가능

- - ← 차집합 : 왼쪽 집합에서 오른쪽 집합의 원소를 뺌
- ^ ← 배타적 차집합 : 공통된 원소를 제외한 모든 원소

1. **세트를지원하는함수**

**-**원소하나를추가하는add( )

-원소하나를제거하는remove( ) 또는discard( )

-새로운리스트를그대로추가하는update( )

-모든변수를지우는clear( )

# 자료구조

- 리스트
- 스택
- 큐 (FIFO)
- 힙
- 검색 트리
- 해시 테이블
- 그래프

# 딕셔너리

********************************************************딕셔너리에 값 추가할 때는 키를 기반으로 값 입력********************************************************

이미 존재한다면 추가한 값으로 바뀜

name이라는 이름은 정의되지 않는다 → 변수로 name을 쓸 수 없음

‘’’ NameError라고 뜸

딕셔너리에서 존재하지 않는 키에 접근할 경우 KeyError가 뜸

딕셔너리 요소 제거로는 del 키워드를 쓰면 됨.

### get() 함수

- 딕셔너리의 키로 값을 추출, 존재하지 않는 키에 접근할 경우 None 출력

딕셔너리 안의 키값만 추출하고 싶다 → keys() 함수 사용

딕셔너리 안의 값만 출출하고 싶다 → values() 함수 사용

키-값 쌍을 모두 보여주고 튜플형식으로 나타낸다 → items() 함수 사용

# 스타일 코드

인간의 시간이 컴퓨터의 시간보다 더 중요하다.

코드가 간결, 작성 시간 단축

### 구분자.join(리스트형) 함수

join()함수를 이용하여 리스트의 각 요소를 빈칸 없이 연결 가능

문자열로 구성된 리스트를 합쳐 하나의 문자열로 만들 때 사용 

### split() 함수

특정 값을 기준으로 문자열을 분리하여 리스트 형태로 변환

## 리스트 컴프리헨션

포괄형=지능형=축약형 리스트

### enumerate() 함수

리스트의 인덱스와 값을 함께 출력 ex:) 0 tic

## 람다함수(lambda)

f = lambda x, y: x + y

print(f(1, 4))

별도의 def나 return을 사용 안함.

람다 함수는 앞에는 매개변수의 이름, 뒤에는 매개변수의 반환값을 입력

함수와 구조만 같을뿐 표현이 다름.

## 맵리듀스의 종류

map()함수, reduce() 함수

- 제너레이터 : 시퀀스 자료형의 데이터를 처리할 때 실행 시점의 값을 생성하여 효율적으로 메모리를 관리할 수 있다는 장점이 있음.

제너레이터 라는 개념때문에 파이썬 3~는 list(map(을 써야함

최근에는 람다함수, map함수를 지양함

## reduce() 함수

리스트와 같은 시퀀스 자료형에 차례대로 함수를 적용한 다음 모든값을 통합시켜 주는 함수

ex) 덧셈이라면 순차적으로 더해나감

## 별표의 사용

args로 묶게되면, **튜플**형식으로 묶임

또한 별표는 가변인수를 사용할 때 사용

**kagrs == 키워드에스터리스크

키워드이기때문에 딕셔너리 형태로 나옴

애초에 튜플 형식으로 args에 넣게 된다면, 언패킹됨. →튜플의 값이 하나이므로

** 별표 두개를 사용하여 언패킹 하면

딕셔너리형을 언패킹 가능

▪ count( ) 함수: 해당 문자열에서 특정 문자가 포함된 개수를 반환
▪ isdigit( ) 함수: 해당 문자열이 숫자인지를 True 또는 False 값으로 반환
▪ startswith( ) 함수: 해당 문자열로 시작하는지를 True 또는 False 값으로 반환
▪ endswith( ) 함수: 해당 문자열로 끝나는지를 True 또는 False 값으로 반환

## 절차 지향

속도가 상대적으로 빠름

## 객체 지향

재사용에 용이

객체, 속성, 행동

객체 : 실생활의 물건같은 개념

속성 : 객체가 가지고 있는 변수 (이름, 나이)

행동 : 말그대로 행동 하는 것

클래스 : 객체가 가지고 있는 코드, 설계도 ( 기계(붕어빵 틀))

### 인스턴스

클래스 내에서 객체가 활성화되면 그것을 인스턴스라고 한다.

그럼 객체를 설정해줘야 활성화가 되겠지?

# 클래스

## 클래스 구현하기

- 파이썬에 클래스를 선언하기 위한 기본 코드 템플릿

class SoccerPlyer(object):

class : 예약어

SoccerPlayer : 클래스 이름

object : 상속받는 객체명

CamelCase를 사용 앞문자에 대문자를 쓰는 것

snake_case : _언더바를 이용해서 변수 작명

a = JSS() 라는 클래스를 만들면 그에 따른 init__ 함수가 실행되지만 밑에 show 함수는 실행되지 않는다.

show 함수를 실행 시키려면

a.show()를 쓰면 된다.

a = self와 같다.

## 상속

super.__init__()이 무조건 있어야 그대로 상속 받을 수 있음

아무것도 수정 안 할 거라면 그냥 pass로 적으면 됨.→ 굳이 쓸 이유가 없다.

# 상속

부모 클래스에 정의된 속성과 메서드를 자식 클래스가 물려받아 사용

## 오버라이딩

상속 받아서 업데이트 하는 행위

이러한 함수의 재정의를 오버라이딩이라함.

## 다형성

같은 이름의 메서드가 다른 기능을 하는 것.

방금 전의 show 함수를 부모클래스에서 사용했는데

자식 클래스에서 다시 show 함수를 정의 했음에 자식클래스에 있는 함수가 사용된 것.

이것이 일종의 다형성이다.

## 크롤러

인터넷에서 데이터를 모으는 프로그램

## 가시성

객체의 정보 접근을 숨기는 것.

## 캡슐화

사용법만 알고 사용한다는 뜻.

설계는 모름

## 정보 은닉

코드 내부를 볼 수 없게 숨기는 것.

### 캡슐화를 하는 이유

클래스 간 간섭 및 정보 공유를 최소화 하여 단독으로 잘 동작할 수 있도록 하기 위해

# 모듈과 패키지

### 인터페이스

함수에서 매개변수를 입력하는 약속

import (.py파일을 참조)

### 패키지

모듈의 묶음

### 네임스페이스

모듈 호출의 범위를 지정

### 랜덤함수

random(), randint()

### 웹 주소 정보 불러오는 함수

urllib

### 절대 참조

모든 경로를 호출

### 상대 참조

 **.series 와 ..crawling.parser** 

점 1 개 는 현재 디렉터리를 ,
점 2 개 는 부모 디렉터리를 의미

## try-except

- 작성 방식 : try문에 예외 발생이 예상되는 코드를 적고, except문에 예외 발생 시 대응하는 코드를 작성함.

```python
try:
	예외 발생 가능 코드
except 예외 타입:
	예외 발생 시 실행되는 코드
```

| IndexError | 리스트의 인덱스 범위를 넘어갈 때 |
| --- | --- |
| NameError | 존재하지 않는 변수를 호출할 때 |
| ZeroDivisionError | 0으로 숫자를 나눌 때 |
| ValueError | 변환할 수 없는 문자나 숫자를 변환할 때 |
| FileNotFoundError | 존재하지 않는 파일을 호출할 때 |

## __str__

리스트 추가 시 , 생락하고 출력

super().__init__(self, gender) 가 아니라

super().__init__(self, name, age)로 부모로 부터 가져오겠다는 정의를 써야함.